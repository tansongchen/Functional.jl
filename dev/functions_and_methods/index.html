<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>函数与方法 · 半个程序员的自我修养</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">半个程序员的自我修养</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">科学计算中的程序设计概论</a></li><li><span class="tocitem">程序设计范式</span><ul><li><a class="tocitem" href="../paradigm_nomenclature/">命名范式</a></li><li><a class="tocitem" href="../paradigm_types_and_functions/">类型与函数范式</a></li><li><a class="tocitem" href="../paradigm_tests/">测试范式</a></li><li><a class="tocitem" href="../paradigm_documentation/">文档范式</a></li></ul></li><li><span class="tocitem">Julia 基础</span><ul><li><a class="tocitem" href="../types/">类型系统</a></li><li><a class="tocitem" href="../intrinsic_types/">内置类型</a></li><li class="is-active"><a class="tocitem" href>函数与方法</a><ul class="internal"><li><a class="tocitem" href="#函数声明-1"><span>函数声明</span></a></li><li><a class="tocitem" href="#匿名函数-1"><span>匿名函数</span></a></li><li><a class="tocitem" href="#元组与多返回值函数-1"><span>元组与多返回值函数</span></a></li><li><a class="tocitem" href="#阵列字面值-1"><span>阵列字面值</span></a></li><li><a class="tocitem" href="#阵列字面值的纵向连接-1"><span>阵列字面值的纵向连接</span></a></li><li><a class="tocitem" href="#阵列推导-1"><span>阵列推导</span></a></li><li><a class="tocitem" href="#生成器-1"><span>生成器</span></a></li><li><a class="tocitem" href="#指标-1"><span>指标</span></a></li><li><a class="tocitem" href="#指标赋值-1"><span>指标赋值</span></a></li><li><a class="tocitem" href="#子阵列-1"><span>子阵列</span></a></li><li><a class="tocitem" href="#广播-1"><span>广播</span></a></li></ul></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../misc/">其他</a></li></ul></li><li><a class="tocitem" href="../topics/">Julia 专题</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia 基础</a></li><li class="is-active"><a href>函数与方法</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>函数与方法</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tansongchen/julia/blob/master/docs/src/functions_and_methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="函数与方法-1"><a class="docs-heading-anchor" href="#函数与方法-1">函数与方法</a><a class="docs-heading-anchor-permalink" href="#函数与方法-1" title="Permalink"></a></h1><h2 id="函数声明-1"><a class="docs-heading-anchor" href="#函数声明-1">函数声明</a><a class="docs-heading-anchor-permalink" href="#函数声明-1" title="Permalink"></a></h2><pre><code class="language-julia">function f(x, y)
end</code></pre><p>也可以用赋值式声明：<code>f(x, y) = x + y</code>。</p><p>函数的返回值可以显式声明，也可以用 <code>return</code> 声明。可以使用 <code>return nothing</code>。</p><h2 id="匿名函数-1"><a class="docs-heading-anchor" href="#匿名函数-1">匿名函数</a><a class="docs-heading-anchor-permalink" href="#匿名函数-1" title="Permalink"></a></h2><p>函数是一等公民，所以可以用如下的方法赋值：</p><pre><code class="language-julia">x -&gt; x^2 + 2x - 1</code></pre><p>这些函数通常传给泛函。</p><h2 id="元组与多返回值函数-1"><a class="docs-heading-anchor" href="#元组与多返回值函数-1">元组与多返回值函数</a><a class="docs-heading-anchor-permalink" href="#元组与多返回值函数-1" title="Permalink"></a></h2><p>元组是多个对象的序列，不可变；可以创建元组。函数返回多值时，是作为元组返回，同时可以进行解构赋值。</p><h2 id="阵列字面值-1"><a class="docs-heading-anchor" href="#阵列字面值-1">阵列字面值</a><a class="docs-heading-anchor-permalink" href="#阵列字面值-1" title="Permalink"></a></h2><p>我们可以通过中括号来创建阵列字面值：<code>[A, B, C, ...]</code>，其中元素类型由它们自动决定：</p><ul><li>如果元素都属于同一类型，就是这个类型；</li><li>如果元素有共同的提升类型，则为提升类型；</li><li>类型为 <code>Any</code>。</li></ul><h2 id="阵列字面值的纵向连接-1"><a class="docs-heading-anchor" href="#阵列字面值的纵向连接-1">阵列字面值的纵向连接</a><a class="docs-heading-anchor-permalink" href="#阵列字面值的纵向连接-1" title="Permalink"></a></h2><p>如果方括号内的元素由分号或者新行连接，那么它们会被认为是元素的集合，而非自身；如果由制表符或空格连接，则会被认为是创建了新的列。实例：</p><pre><code class="language-julia">[1:2; 4:5] # 4 × 1
[1:2 4:5] # 2 × 2
[1 2 3] # 1 × 3
[1 2; 3 4] # 2 × 2</code></pre><p>这些只不过是一个函数的别名：</p><ul><li><code>cat</code>：在任意维度上组合；</li><li><code>vcat</code>：在一维上组合；</li><li><code>hcat</code>：在二维上组合；</li></ul><h2 id="阵列推导-1"><a class="docs-heading-anchor" href="#阵列推导-1">阵列推导</a><a class="docs-heading-anchor-permalink" href="#阵列推导-1" title="Permalink"></a></h2><p>通用的语法：</p><pre><code class="language-julia">A = [ F(x, y, ...) for x = rx, y = ry, ...]</code></pre><p>这里 <code>rx, ry</code> 都是可迭代对象。</p><h2 id="生成器-1"><a class="docs-heading-anchor" href="#生成器-1">生成器</a><a class="docs-heading-anchor-permalink" href="#生成器-1" title="Permalink"></a></h2><p>若列表不包含括号，则视为一个生成器，通过迭代来得到值，而不需要任何阵列。</p><h2 id="指标-1"><a class="docs-heading-anchor" href="#指标-1">指标</a><a class="docs-heading-anchor-permalink" href="#指标-1" title="Permalink"></a></h2><p>函数形式：<code>getindex(A, ...)</code></p><h3 id="标量指标-1"><a class="docs-heading-anchor" href="#标量指标-1">标量指标</a><a class="docs-heading-anchor-permalink" href="#标量指标-1" title="Permalink"></a></h3><p>如果所有的指标都是标量，那么结果是一个元素；</p><h3 id="向量指标-1"><a class="docs-heading-anchor" href="#向量指标-1">向量指标</a><a class="docs-heading-anchor-permalink" href="#向量指标-1" title="Permalink"></a></h3><p>如果所有的指标都是向量，那么结果是一个 N 维阵列，阵列的大小是 <code>length(I_1), ...., length(I_n)</code>。</p><h3 id="二维阵列指标-1"><a class="docs-heading-anchor" href="#二维阵列指标-1">二维阵列指标</a><a class="docs-heading-anchor-permalink" href="#二维阵列指标-1" title="Permalink"></a></h3><p>结果是一个 N+1 维阵列，大小是 <code>size(I_1, 1), size(I_1, 2), ...</code></p><h2 id="指标赋值-1"><a class="docs-heading-anchor" href="#指标赋值-1">指标赋值</a><a class="docs-heading-anchor-permalink" href="#指标赋值-1" title="Permalink"></a></h2><p>函数形式：<code>setindex!(A, X, ...)</code></p><h2 id="子阵列-1"><a class="docs-heading-anchor" href="#子阵列-1">子阵列</a><a class="docs-heading-anchor-permalink" href="#子阵列-1" title="Permalink"></a></h2><p>子阵列与母阵列共享同样的内存，可以通过 <code>view</code> 创建，它的参数与 <code>getindex()</code> 相同。</p><h2 id="广播-1"><a class="docs-heading-anchor" href="#广播-1">广播</a><a class="docs-heading-anchor-permalink" href="#广播-1" title="Permalink"></a></h2><p>当我们需要在不同大小的阵列间进行二元运算时，我们可以用广播函数将大小为一的维度扩增然后进行运算：</p><pre><code class="language-julia">a = rand(2, 1);
A = rand(2, 3);
broadcast(+, a, A);</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intrinsic_types/">« 内置类型</a><a class="docs-footer-nextpage" href="../metaprogramming/">元编程 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 17 April 2021 07:30">Saturday 17 April 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
