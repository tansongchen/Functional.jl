<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>类型系统 · 半个程序员的自我修养</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">半个程序员的自我修养</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">科学计算中的程序设计概论</a></li><li><span class="tocitem">程序设计范式</span><ul><li><a class="tocitem" href="../paradigm_nomenclature/">命名范式</a></li><li><a class="tocitem" href="../paradigm_types_and_functions/">类型与函数范式</a></li><li><a class="tocitem" href="../paradigm_tests/">测试范式</a></li><li><a class="tocitem" href="../paradigm_documentation/">文档范式</a></li></ul></li><li><span class="tocitem">Julia 基础</span><ul><li class="is-active"><a class="tocitem" href>类型系统</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#具象类型-1"><span>具象类型</span></a></li><li><a class="tocitem" href="#原始类型-1"><span>原始类型</span></a></li><li><a class="tocitem" href="#复合类型-1"><span>复合类型</span></a></li><li><a class="tocitem" href="#类型并集-1"><span>类型并集</span></a></li><li class="toplevel"><a class="tocitem" href="#参数化类型-1"><span>参数化类型</span></a></li><li><a class="tocitem" href="#以类型为参数的复合类型-1"><span>以类型为参数的复合类型</span></a></li><li><a class="tocitem" href="#参数类型的构造函数-1"><span>参数类型的构造函数</span></a></li><li><a class="tocitem" href="#参数抽象类型-1"><span>参数抽象类型</span></a></li><li><a class="tocitem" href="#参数原始类型-1"><span>参数原始类型</span></a></li><li><a class="tocitem" href="#UnionAll-类型-1"><span><code>UnionAll</code> 类型</span></a></li><li><a class="tocitem" href="#类型操作-1"><span>类型操作</span></a></li><li><a class="tocitem" href="#值类-1"><span>值类</span></a></li></ul></li><li><a class="tocitem" href="../intrinsic_types/">内置类型</a></li><li><a class="tocitem" href="../functions_and_methods/">函数与方法</a></li><li><a class="tocitem" href="../metaprogramming/">元编程</a></li><li><a class="tocitem" href="../misc/">其他</a></li></ul></li><li><a class="tocitem" href="../topics/">Julia 专题</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia 基础</a></li><li class="is-active"><a href>类型系统</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>类型系统</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tansongchen/julia/blob/master/docs/src/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="类型系统-1"><a class="docs-heading-anchor" href="#类型系统-1">类型系统</a><a class="docs-heading-anchor-permalink" href="#类型系统-1" title="Permalink"></a></h1><p>Julia 中的类型分为抽象类型和具象类型，其中抽象类型是不可实例化的，而具象类型是可以实例化。类型之间构成了类型树，所有的具象类型都是树的叶节点，而所有的抽象类型都是树的非叶节点。</p><p>类型的类型是 <code>DataType</code>。</p><p>类型树：</p><ul><li><code>Any</code><ul><li><code>Number</code><ul><li><code>Real</code><ul><li><code>Integer</code><ul><li><code>Signed</code></li><li><code>Unsigned</code></li></ul></li><li><code>AbstractFloat</code></li></ul></li></ul></li><li><code>AbstractString</code></li></ul></li></ul><p>抽象类型的声明：</p><pre><code class="language-julia">abstract type $typeName end
abstract type $typeName &lt;: $supertypeName end</code></pre><h1 id="具象类型-1"><a class="docs-heading-anchor" href="#具象类型-1">具象类型</a><a class="docs-heading-anchor-permalink" href="#具象类型-1" title="Permalink"></a></h1><h2 id="原始类型-1"><a class="docs-heading-anchor" href="#原始类型-1">原始类型</a><a class="docs-heading-anchor-permalink" href="#原始类型-1" title="Permalink"></a></h2><p><strong>原始类型</strong>：数据只包含特定数量的比特。</p><pre><code class="language-julia">primitive type $typeName $typeBits end
primitive type $typeName &lt;: $supertypeName $typeBits end</code></pre><p>实例：</p><ul><li><code>AbstractFloat</code> 抽象类型衍生了 <code>Float16, Float32, Float64</code></li><li><code>Integer</code> 抽象类型衍生了 <code>Bool</code></li><li><code>Signed</code> 抽象类型衍生了 <code>Int8 ~ Int128</code></li><li><code>Unsigned</code> 抽象类型衍生了 <code>UInt8 ~ UInt128</code></li><li><code>AbstractChar</code> 抽象类型衍生了 <code>Char</code></li></ul><h2 id="复合类型-1"><a class="docs-heading-anchor" href="#复合类型-1">复合类型</a><a class="docs-heading-anchor-permalink" href="#复合类型-1" title="Permalink"></a></h2><p>复合类型包含了一系列命名的域，每个域都是一个原始类型或复合类型。</p><p>声明方式：</p><pre><code class="language-julia">struct Foo
    bar
    baz::Int
    qux::Float64
end</code></pre><p>查看域：<code>fieldnames(Foo)</code></p><p>访问域：<code>foo.bar</code></p><p>复合类型是不可变的；如果可变，则要声明为 <code>mutable struct</code>。</p><p>不可变的、不含任何域的复合类型是单例类型。</p><h3 id="构造函数-1"><a class="docs-heading-anchor" href="#构造函数-1">构造函数</a><a class="docs-heading-anchor-permalink" href="#构造函数-1" title="Permalink"></a></h3><p>自带两个构造函数：</p><ul><li>接受任何参数，并转换为类型</li><li>只接受对应的参数</li></ul><h2 id="类型并集-1"><a class="docs-heading-anchor" href="#类型并集-1">类型并集</a><a class="docs-heading-anchor-permalink" href="#类型并集-1" title="Permalink"></a></h2><p>类型并集是一个抽象类型，它包括了所有的成员所能包括的对象。</p><h1 id="参数化类型-1"><a class="docs-heading-anchor" href="#参数化类型-1">参数化类型</a><a class="docs-heading-anchor-permalink" href="#参数化类型-1" title="Permalink"></a></h1><h2 id="以类型为参数的复合类型-1"><a class="docs-heading-anchor" href="#以类型为参数的复合类型-1">以类型为参数的复合类型</a><a class="docs-heading-anchor-permalink" href="#以类型为参数的复合类型-1" title="Permalink"></a></h2><pre><code class="language-julia">struct Point{T}
    x::T
    y::T
end</code></pre><p>这定义了无穷多可能的类型，例如 <code>Point{Float64}</code> 是一个具象类型。</p><p>参数复合类型本身也是一个类型，并且是所有参数化后的类型的基类：</p><pre><code class="language-julia">Point{Float64} &lt;: Point</code></pre><p>函数定义</p><pre><code class="language-julia">function norm(p::Point{&lt;:Real})
    sqrt(p.x^2 + p.y^2)
end</code></pre><h2 id="参数类型的构造函数-1"><a class="docs-heading-anchor" href="#参数类型的构造函数-1">参数类型的构造函数</a><a class="docs-heading-anchor-permalink" href="#参数类型的构造函数-1" title="Permalink"></a></h2><ol><li>类型参数显明的给出</li><li>通过参数动态确定</li></ol><p>例如，</p><pre><code class="language-julia">Point{Float64}(1.0, 2.0)</code></pre><p>也可以用未参数化的形式</p><pre><code class="language-julia">Point(1.0, 2.0)</code></pre><h2 id="参数抽象类型-1"><a class="docs-heading-anchor" href="#参数抽象类型-1">参数抽象类型</a><a class="docs-heading-anchor-permalink" href="#参数抽象类型-1" title="Permalink"></a></h2><pre><code class="language-julia">abstract type Pointy{T} end</code></pre><p>给定任意 T 的值，都会生成一个类型。同时它们也满足</p><pre><code class="language-julia">Pointy{Float64} &lt;: Pointy{&lt;:Real}</code></pre><p>我们可以定义一个参数复合类型作为它的具象化类型，也是子类型。</p><pre><code class="language-julia">abstract type Pointy{T&lt;:Real} end</code></pre><p>例如，</p><pre><code class="language-julia">struct Rational{T&lt;:Integer} &lt;: Real ... end</code></pre><h3 id="元组类型-1"><a class="docs-heading-anchor" href="#元组类型-1">元组类型</a><a class="docs-heading-anchor-permalink" href="#元组类型-1" title="Permalink"></a></h3><p>元组类型实际上是一个元组的类型，它对应着一个任意多参数的参数复合类型。与其他不同的是，元组类型的参数是协变的，也即</p><pre><code class="language-julia">Tuple{Int,AbstractString} &lt;: Tuple{Real,Any}</code></pre><p>元组类型的最后一个参数可以是 <code>Vararg</code> 类型，这表明元组的最后可以包含任何种类的数据。另外 <code>NTuple{N,T}</code> 是 <code>Tuple{Vararg{T,N}}</code> 的别名。</p><h3 id="命名元组类型-1"><a class="docs-heading-anchor" href="#命名元组类型-1">命名元组类型</a><a class="docs-heading-anchor-permalink" href="#命名元组类型-1" title="Permalink"></a></h3><p>命名元组有两个参数：第一个参数是符号元组，第二个参数是元组类型。</p><p>命名元组可以作为一个构造函数，构造时可以包括两个参数，也可以只包括符号元组的参数。</p><h3 id="单实例类型-1"><a class="docs-heading-anchor" href="#单实例类型-1">单实例类型</a><a class="docs-heading-anchor-permalink" href="#单实例类型-1" title="Permalink"></a></h3><p>对于所有类型来说，<code>Type{T}</code> 是一个抽象类型，它唯一的实例是该类型。另外 <code>Type</code> 本身也是一个基类。</p><h2 id="参数原始类型-1"><a class="docs-heading-anchor" href="#参数原始类型-1">参数原始类型</a><a class="docs-heading-anchor-permalink" href="#参数原始类型-1" title="Permalink"></a></h2><p>原始类型也可以参数声明，例如指针依赖于类型：</p><pre><code class="language-julia">primitive type Ptr{T} 64 end</code></pre><p>在这里，类型参数只是一个标签，而不参与自身的定义。</p><h2 id="UnionAll-类型-1"><a class="docs-heading-anchor" href="#UnionAll-类型-1"><code>UnionAll</code> 类型</a><a class="docs-heading-anchor-permalink" href="#UnionAll-类型-1" title="Permalink"></a></h2><p>参数类型的类型实际上是 <code>UnionAll</code>。所有的类型应用 <code>A{B,C}</code> 都要求 <code>A</code> 的类型是 <code>UnionAll</code>，并且我们可以部分地实例化它。</p><p>类型变量可以通过子类关系来限制。</p><h2 id="类型操作-1"><a class="docs-heading-anchor" href="#类型操作-1">类型操作</a><a class="docs-heading-anchor-permalink" href="#类型操作-1" title="Permalink"></a></h2><p>由于类型本身是对象，可以用操作来处理它们。</p><pre><code class="language-julia">isa(1, Int)
typeof(Rational)
supertype(Number)</code></pre><p>所有的类型的类型都是 <code>DataType</code>，它是自身的类型。</p><p>所有的类型的基类都是 <code>Any</code>。</p><h2 id="值类-1"><a class="docs-heading-anchor" href="#值类-1">值类</a><a class="docs-heading-anchor-permalink" href="#值类-1" title="Permalink"></a></h2><p>我们不能根据对象是什么来派发，但我们可以将纯比特数据（通过参数）封装成一个类型，因而使用。例如，我们定义两个函数：</p><pre><code class="language-julia">firstlast(::Val{true}) = &quot;First&quot;
firstlast(::Val{false}) = &quot;Last</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../paradigm_documentation/">« 文档范式</a><a class="docs-footer-nextpage" href="../intrinsic_types/">内置类型 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 17 April 2021 07:30">Saturday 17 April 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
