<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>元编程 · 半个程序员的自我修养</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">半个程序员的自我修养</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">科学计算中的程序设计概论</a></li><li><span class="tocitem">程序设计范式</span><ul><li><a class="tocitem" href="../paradigm_nomenclature/">命名范式</a></li><li><a class="tocitem" href="../paradigm_types_and_functions/">类型与函数范式</a></li><li><a class="tocitem" href="../paradigm_tests/">测试范式</a></li><li><a class="tocitem" href="../paradigm_documentation/">文档范式</a></li></ul></li><li><span class="tocitem">Julia 基础</span><ul><li><a class="tocitem" href="../types/">类型系统</a></li><li><a class="tocitem" href="../intrinsic_types/">内置类型</a></li><li><a class="tocitem" href="../functions_and_methods/">函数与方法</a></li><li class="is-active"><a class="tocitem" href>元编程</a><ul class="internal"><li><a class="tocitem" href="#表达式对象的结构-1"><span>表达式对象的结构</span></a></li><li><a class="tocitem" href="#创建表达式对象-1"><span>创建表达式对象</span></a></li><li><a class="tocitem" href="#创建表达式对象的同时进行插值-1"><span>创建表达式对象的同时进行插值</span></a></li><li class="toplevel"><a class="tocitem" href="#符号对象-1"><span>符号对象</span></a></li><li class="toplevel"><a class="tocitem" href="#表达式求值-1"><span>表达式求值</span></a></li><li><a class="tocitem" href="#以表达式为值的函数-1"><span>以表达式为值的函数</span></a></li><li class="toplevel"><a class="tocitem" href="#宏-1"><span>宏</span></a></li><li><a class="tocitem" href="#宏的使用-1"><span>宏的使用</span></a></li><li class="toplevel"><a class="tocitem" href="#元编程的应用-1"><span>元编程的应用</span></a></li><li><a class="tocitem" href="#自定义类-1"><span>自定义类</span></a></li><li><a class="tocitem" href="#自定义字符串字面值-1"><span>自定义字符串字面值</span></a></li><li><a class="tocitem" href="#生成函数-1"><span>生成函数</span></a></li></ul></li><li><a class="tocitem" href="../misc/">其他</a></li></ul></li><li><a class="tocitem" href="../topics/">Julia 专题</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Julia 基础</a></li><li class="is-active"><a href>元编程</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>元编程</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tansongchen/julia/blob/master/docs/src/metaprogramming.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="元编程-1"><a class="docs-heading-anchor" href="#元编程-1">元编程</a><a class="docs-heading-anchor-permalink" href="#元编程-1" title="Permalink"></a></h1><h2 id="表达式对象的结构-1"><a class="docs-heading-anchor" href="#表达式对象的结构-1">表达式对象的结构</a><a class="docs-heading-anchor-permalink" href="#表达式对象的结构-1" title="Permalink"></a></h2><ul><li><code>expr.head</code>：一个符号，表明了表达式的类型</li><li><code>expr.args</code>：一个列表，表明了表达式的参数，可以是符号、其他表达式或字面值</li></ul><h2 id="创建表达式对象-1"><a class="docs-heading-anchor" href="#创建表达式对象-1">创建表达式对象</a><a class="docs-heading-anchor-permalink" href="#创建表达式对象-1" title="Permalink"></a></h2><p>将 Julia 语言的一个合法表达式用适当的方式引用起来，就形成了一个表达式对象：</p><pre><code class="language-julia">expr = :(1 + 1)
expr = Expr(:call, :+, 1, 1)
expr = Meta.parse(&quot;1 + 1&quot;)</code></pre><p>当我们需要多行的表达式时，也可以使用 <code>quote</code> 语法：</p><pre><code class="language-julia">expr = quote
    x = 1
    y = 2
    x + y
end</code></pre><h2 id="创建表达式对象的同时进行插值-1"><a class="docs-heading-anchor" href="#创建表达式对象的同时进行插值-1">创建表达式对象的同时进行插值</a><a class="docs-heading-anchor-permalink" href="#创建表达式对象的同时进行插值-1" title="Permalink"></a></h2><p>我们可以将字面值或表达式作为新表达式的一部分插入，并用 <code>$</code> 号标记：</p><pre><code class="language-julia">a = 1
expr = :($a + b)</code></pre><p>我们也可以先将一个变量展开，然后再插值：</p><pre><code class="language-julia">args = [:x, :y, :z]
:(f(1, $(args...)))</code></pre><h1 id="符号对象-1"><a class="docs-heading-anchor" href="#符号对象-1">符号对象</a><a class="docs-heading-anchor-permalink" href="#符号对象-1" title="Permalink"></a></h1><p>用 : 可以创建一个符号：</p><pre><code class="language-none">:foo
Symbol(&quot;foo&quot;)</code></pre><p>当表达式被求值的时候，一个符号会被一个变量替代。</p><h1 id="表达式求值-1"><a class="docs-heading-anchor" href="#表达式求值-1">表达式求值</a><a class="docs-heading-anchor-permalink" href="#表达式求值-1" title="Permalink"></a></h1><p>我们可以在全局作用域来对表达式进行求值：</p><pre><code class="language-julia">eval(:(1 + 1)) # =2</code></pre><p>每个模块都有自己的求值函数。表达式不仅能返回一个值，还能影响模块的环境：</p><pre><code class="language-julia">expr = :(x = 1)
eval(expr)
x # 1</code></pre><h2 id="以表达式为值的函数-1"><a class="docs-heading-anchor" href="#以表达式为值的函数-1">以表达式为值的函数</a><a class="docs-heading-anchor-permalink" href="#以表达式为值的函数-1" title="Permalink"></a></h2><p>在函数中，我们可以使 <code>Expr</code> 函数构建表达式，并将其返回。</p><h1 id="宏-1"><a class="docs-heading-anchor" href="#宏-1">宏</a><a class="docs-heading-anchor-permalink" href="#宏-1" title="Permalink"></a></h1><p>宏接受一系列参数（可以是符号、字面值和表达式），然后将它们转化为一个表达式，这个表达式能够直接参与编译。</p><pre><code class="language-julia">macro sayhello(name)
    return :( println(&quot;Hello, &quot;, $name) )
end</code></pre><p>我们可以用 <code>macroexpand</code> 函数来测试宏：</p><pre><code class="language-julia">expr = macroexpand(Main, :(@sayhello(&quot;human&quot;)))
expr = @macroexpand @sayhello &quot;human&quot;</code></pre><h2 id="宏的使用-1"><a class="docs-heading-anchor" href="#宏的使用-1">宏的使用</a><a class="docs-heading-anchor-permalink" href="#宏的使用-1" title="Permalink"></a></h2><p>宏可以用三种不同的语法使用：</p><pre><code class="language-julia">@name expr1 expr2 ...
@name(expr1, expr2, ...)
@name[a b]</code></pre><p>除了给定的参数外，宏还有两个额外的参数：<code>__source__</code> 和 <code>__module__</code>，第一个可以用于查看调用的位置，而第二个反映了调用的上下文。</p><p>宏也是泛型的，可以接受很多个参数，但参数的类型是 AST 中的类型，而不是变量所代表的对象。</p><h1 id="元编程的应用-1"><a class="docs-heading-anchor" href="#元编程的应用-1">元编程的应用</a><a class="docs-heading-anchor-permalink" href="#元编程的应用-1" title="Permalink"></a></h1><h2 id="自定义类-1"><a class="docs-heading-anchor" href="#自定义类-1">自定义类</a><a class="docs-heading-anchor-permalink" href="#自定义类-1" title="Permalink"></a></h2><p>考虑一个仅包含浮点数的自定义类，我们可以通过如下方式快速操作：</p><pre><code class="language-julia">for op = (:sin,:cos,:tan,:log,:exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end</code></pre><h2 id="自定义字符串字面值-1"><a class="docs-heading-anchor" href="#自定义字符串字面值-1">自定义字符串字面值</a><a class="docs-heading-anchor-permalink" href="#自定义字符串字面值-1" title="Permalink"></a></h2><p>正则表达式实际上是一个具有特殊语法的宏：</p><pre><code class="language-julia">macro r_str(p)
    Regex(p)
end</code></pre><p>这样，我们就能使用 <code>r&quot;string&quot;</code> 这样的表达了。</p><p>另外，我们也可以定义特殊的命令字面值，通过 c`literal` 我们实际上获得的是 <code>@c_cmd &quot;literal&quot;</code>。</p><h2 id="生成函数-1"><a class="docs-heading-anchor" href="#生成函数-1">生成函数</a><a class="docs-heading-anchor-permalink" href="#生成函数-1" title="Permalink"></a></h2><p>生成函数能让我们生成专门化的代码，取决于参数的种类，而不需要每种都用多重派发来实现。这样的函数返回一个引用的表达式作为方法的函数体，然后进行编译。具体的做法是：</p><ol><li>用 <code>@generated</code> 标记该宏；</li><li>在函数体中，我们通过变量的类型生成应该实现的代码并返回；</li><li>生成函数只能调用那些已经定义好的函数；</li><li>生成函数不能改变全局状态。</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functions_and_methods/">« 函数与方法</a><a class="docs-footer-nextpage" href="../misc/">其他 »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 21 July 2020 14:52">Tuesday 21 July 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
