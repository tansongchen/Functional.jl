var documenterSearchIndex = {"docs":
[{"location":"paradigm_nomenclature/#命名范式-1","page":"命名范式","title":"命名范式","text":"","category":"section"},{"location":"paradigm_nomenclature/#命名对象与一般讨论-1","page":"命名范式","title":"命名对象与一般讨论","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"在 Julia 中，可命名的实体分为三类：类型、函数和值。在最高的层次上概括地说，这三类实体采取以下的命名方式：","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"类型：大驼峰式命名（每个单词的首字母大写并连接在一起）\n函数和值：小驼峰式命名（除第一个单词外每个单词的首字母大写并连接在一起）或单字母命名（见下）","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"大驼峰和小驼峰是软件开发中常用的命名方式，并且也是 Python 和 JavaScript 中许多内置函数和标准库中的命名方式，因此无需赘述。单字母命名则需要进行一些说明。在软件开发领域，单字母命名通常被认为是不好的命名方式，仅仅应该在类似于「很小的循环中的循环变量」这种场合加以使用。但在科学计算领域，由于数学公式中所有代数记号通常都是单字母的（单个英文字母、希腊字母或其他字母，并用上标、下标、改变字体等其他方式加以进一步区分），因而所有物理量也几乎都是单字母的。例如 beta 在统计力学中几乎总是代表温度倒数，如果一定要在程序中把它命名为 inverseTemperature 虽然不是不可以，但徒增了理解上的「噪音」。对于这种情况，直接使用 β 作为变量名就是很好的选择（Julia 可以用 Unicode 字符作变量名）。使用单字母命名时可以无视大小写的要求，也可以带上相应的上标或者下标（例如量子微扰论中可以使用 H₀ 作为变量名）。","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"但是物理量和「不是物理量」没有特别明显的区分，例如计算过程中的一些中间变量通常没有公认的单字母命名。为此我们提出了「背书原则」来解决这个问题：假设我们的研究工作要发表为一篇论文，那么所有在论文中出现的物理量单字母记法都可以作为程序中的单字母命名，否则就用小驼峰式命名。在「文档范式」中我们会进一步讨论如何将写论文和写程序之间实现「联动」。","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"（「背书原则」的「背书」出处：「在政治上，背书一词用来表示为某人或某事允诺保证，借此提高事物的可信度。该词来自金融术语，原意指在支票等背后签名表示支付、收到或同意转让等。」——引自维基百科。代码就是「支票」的正面，而论文就是「支票」的背面。）","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"下面我们讨论一些基本原则：","category":"page"},{"location":"paradigm_nomenclature/#能使用单字母命名就不要使用小驼峰式命名-1","page":"命名范式","title":"能使用单字母命名就不要使用小驼峰式命名","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"有论文背书的时候，单字母命名显得易懂得多，与科学计算的主旨也更符合。特别是能使用单个希腊字母就不要使用它的英文转写（β = 1 而不是 beta = 1），能把含义用上下标表达就不用另一个单词（H₀ 而不是 primitiveHamiltonian）。","category":"page"},{"location":"paradigm_nomenclature/#大小驼峰式命名采用完整的英文单词-1","page":"命名范式","title":"大小驼峰式命名采用完整的英文单词","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"完整的英文单词比较不好写。但是，正如《代码整洁之道》中所说的，一方面写程序时读以前代码的时间远多于写新代码的时间，另一方面现代编辑器的自动补全功能使得真正需要打的字符数量也大大减少了。例如一个描述一维量子系统的类型可能会被命名为 1dqs，但这看起来像是乱码。我们不如写","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"struct OneDimensionalQuantumSystem\n    β::Real\n    ...\nend","category":"page"},{"location":"paradigm_nomenclature/#类型命名-1","page":"命名范式","title":"类型命名","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"类型命名是比较好解决的。正如「类型与函数范式」一节中提到的，类型一般表示某个物理概念，例如「传播子」「同构经典系统」等等，把这个概念逐词翻译成英语就可以了。","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"类型命名很大程度上决定了文件命名，因为一个文件在理想情况下应该包含的是一个类型和相应的方法，此时我们把文件的名字和类型的名字等同起来就可以了。","category":"page"},{"location":"paradigm_nomenclature/#函数命名-1","page":"命名范式","title":"函数命名","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"首先排除那些单字母命名的情况。在函数的小驼峰式命名中，我们还可以进一步分为两种情况：","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"如果函数有返回值，那么函数的命名就是返回值的命名，这样转化为了一个值命名的问题。这样做是因为在函数式语言中，函数和函数的返回值在概念上没有多大的区别（例如 Lisp 里不区分值和函数、Fortran 里如果不使用 result() 语法则函数名可以直接在函数体中当成值的名称使用）。那么问题来了，如果返回值也需要命名，怎么办？首先，在 Julia 里面返回值可以不写 return，例如","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"f(x) = begin\n    y = 2x\n    y^2 + 1\nend","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"自动返回 y^2 + 1，因此返回的那个值在函数体中只会以表达式的形式出现。而如果你是先创建一个值，再把一些其他的值累加上去，然后返回，那确实会引起问题，但这种情况的出现一般说明程序写得不好（函数式编程里极少使用变量），应该考虑用 sum() 之类的函数来代替。","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"如果函数没有返回值，这实际上已经不属于函数式编程的范畴了，其效果肯定是对某个参数作出了修改，此时应该把修改动作的动词作为函数名称并加上感叹号，例如 push!()。","category":"page"},{"location":"paradigm_nomenclature/#值命名-1","page":"命名范式","title":"值命名","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"除了单字母命名外，值的小驼峰式命名应该遵守以下几个原则：","category":"page"},{"location":"paradigm_nomenclature/#不说废话-1","page":"命名范式","title":"不说废话","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"「不说废话」有几层含义。首先，Julia 是强类型语言，我们可以通过写类型标注的方式让编辑器随时告诉我们一个变量的类型，所以没必要标注类型，例如 preconditionerMatrix 就不如 preconditioner。其次，尽量使用实词而非虚词和词根词缀。考虑一个简单的循环，","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"for phase in phases\n    ...\nend","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"phases 的类型是 Array{Phase, 1}，但这个命名没有体现出这个阵列中各个 phase 之间是什么关系。例如如果实际上它们是不同的样本，可以命名为 phaseReplicates。同理不要写 aPhase，thePhase。","category":"page"},{"location":"paradigm_nomenclature/#把字面值变成常量-1","page":"命名范式","title":"把字面值变成常量","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"for i in 1:200000\n    integrator!(phase, system)\n    if mod(i, 10000) == 0\n        collect!(property, phase, system)\n    end\nend","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"这段程序想干什么？200000 和 10000 分别有什么意义？如果我们先定义 const iterationTimes = 200000 和 const collectEveryThisTimes = 10000，然后把这些常量的名称放入程序中，程序的意义就明确多了。","category":"page"},{"location":"paradigm_nomenclature/#一词一义-1","page":"命名范式","title":"一词一义","text":"","category":"section"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"把多词一义变成一词一义：程序的编写可能经过多个人之手，即使自己编写也可能历经比较长的一段时间，在这段时间内我们指向一个概念的用语可能会发生波动。例如 map, operator, transformation 可能都是指的某类映射，这时需要统一以避免混乱。","category":"page"},{"location":"paradigm_nomenclature/#","page":"命名范式","title":"命名范式","text":"把一词多义变成一词一义：假设我们给两种不同的类型都定义了二元函数 +，但 A 类型 x + y = y + x，而 B 类型 x + y != y + x，那么我们不妨把 B 类型的这个函数改名叫 * 或者 × 等等，这样更符合习惯。","category":"page"},{"location":"intrinsic_types/#内置类型-1","page":"内置类型","title":"内置类型","text":"","category":"section"},{"location":"intrinsic_types/#变量命名要求与规范-1","page":"内置类型","title":"变量命名要求与规范","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"以字母、下划线、Unicode 字符开始；\n后续可以包括数字等；\n以中缀操作符开头的变量名会被当作中缀操作符。","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"但是，我们应该注意这些规范：","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"变量为小写；\n词间可以用下划线分开；\n类和模块用大写；\n函数和宏小写；\n副作用函数以 ! 结尾。","category":"page"},{"location":"intrinsic_types/#整数与浮点数-1","page":"内置类型","title":"整数与浮点数","text":"","category":"section"},{"location":"intrinsic_types/#整数与浮点数的类型-1","page":"内置类型","title":"整数与浮点数的类型","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"整数类型：有符号和无符号的 8、16、32、64、128 位整数，以及布尔值；别名 Int, UInt 指向的是系统的位数；\n浮点数类型：16、32、64 位。","category":"page"},{"location":"intrinsic_types/#整数字面值类型-1","page":"内置类型","title":"整数字面值类型","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"有符号整数字面值：32 或 64 位系统，但是大整数只能是 64 位的；\n无符号整数字面值：需要通过 16、8 或 2 进制指定，分别为 0x, 0b, 0o；如果首位为 0，则按位数指定大小，否则按实际大小指定大小。","category":"page"},{"location":"intrinsic_types/#整数溢出与除法的解决-1","page":"内置类型","title":"整数溢出与除法的解决","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"当数据向上溢出时，通常将转化为最小值。","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"当除以 0 或最小值除以 -1 时，会报错。","category":"page"},{"location":"intrinsic_types/#浮点数字面值类型-1","page":"内置类型","title":"浮点数字面值类型","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"双精度数：可以用浮点数或科学计数法；\n单精度数：可以用 f 代替 e","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"浮点数之间可以用 Float32() 转换。","category":"page"},{"location":"intrinsic_types/#浮点数相关规范-1","page":"内置类型","title":"浮点数相关规范","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"存在两个零，它们相等但有不同的 bitstring() 函数\n正负无穷和非数都有三个实现：\nInf16, Inf32, Inf：大于所有的有限浮点数；\n-Inf16, -Inf32, -Inf：小于所有的有限浮点数；\nNaN16, NaN32, NaN：不等于所有浮点数\n正负无穷同时还是 typemin(), typemax() 的结果","category":"page"},{"location":"intrinsic_types/#数值字面值系数-1","page":"内置类型","title":"数值字面值系数","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"字面值在变量前时，可以省略乘号。这种「隐式乘」运算的优先级要低于一元算符，高于二元算符，但与指数结合时则类似于一个一元算符。","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"数值字面值在括号前，也可以省略系数；括号内的表达式也可以看成是一个系数。","category":"page"},{"location":"intrinsic_types/#字面值零和一-1","page":"内置类型","title":"字面值零和一","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"zero() 和 one() 返回对应类型的零和一。","category":"page"},{"location":"intrinsic_types/#数学运算与初等函数-1","page":"内置类型","title":"数学运算与初等函数","text":"","category":"section"},{"location":"intrinsic_types/#算术运算与位运算-1","page":"内置类型","title":"算术运算与位运算","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"特别的几个：","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"div\n表示整数除法；\nbackslash\n表示反除法；\n异或；","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"所有算术运算与位运算都有对应的更新算符，但更新算符可能会改变变量类型。","category":"page"},{"location":"intrinsic_types/#向量化算符-1","page":"内置类型","title":"向量化算符","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"对每个一元和二元算符，在前面加上点就得到了对数组的向量化算符。","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"[1,2,3] .^ 3","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"这种运算也可以用宏实现：@.。","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"点运算也可以用于自定义的算符。","category":"page"},{"location":"intrinsic_types/#数值比较-1","page":"内置类型","title":"数值比较","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"正零不大于负零；\n正负无穷与自身相等；\n非数不与任何数相等、小于或大于\n额外的函数：\nisequal(x, y)\nisfinite(x)\nisinf(x)\nisnan(x)","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"这里 isequal() 使得非数也彼此相等。","category":"page"},{"location":"intrinsic_types/#数值转换-1","page":"内置类型","title":"数值转换","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"T(x) 转换，如果无法用整数表示则产生错误；\nx % T 返回模 2^n 同余的数；\nround(Int, x) 返回先取整再转换的值。","category":"page"},{"location":"intrinsic_types/#复数与浮点数-1","page":"内置类型","title":"复数与浮点数","text":"","category":"section"},{"location":"intrinsic_types/#复数-1","page":"内置类型","title":"复数","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"复数可以用 1 + 2im 的形式指定，也可以用 complex(a, b) 的形式创建。","category":"page"},{"location":"intrinsic_types/#有理数-1","page":"内置类型","title":"有理数","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"有理数用 2//3 的形式创建，并且可以转换为浮点数：","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"isequal(float(a//b), a/b)","category":"page"},{"location":"intrinsic_types/#字符与字符串-1","page":"内置类型","title":"字符与字符串","text":"","category":"section"},{"location":"intrinsic_types/#字符-1","page":"内置类型","title":"字符","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"Char 类型是一个 32 位的原生类型，可以通过编码值或者换为数字。","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"可以通过 \\u 字符串来展示任何字符。","category":"page"},{"location":"intrinsic_types/#字符串-1","page":"内置类型","title":"字符串","text":"","category":"section"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"字符串的下标语法：str[begin]，str[1]。注意 begin 和 end 也可以当作数来运算。并不是每一个下标都合法，但我们可以通过迭代器来操作。字符串的常见运算：","category":"page"},{"location":"intrinsic_types/#","page":"内置类型","title":"内置类型","text":"连接：string(a, b, ...)\n乘法：a * b * c * ...\n传值：$a、$(1+2)","category":"page"},{"location":"paradigm_types_and_functions/#类型与函数范式-1","page":"类型与函数范式","title":"类型与函数范式","text":"","category":"section"},{"location":"paradigm_types_and_functions/#类型与函数范式概论-1","page":"类型与函数范式","title":"类型与函数范式概论","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"作为支持多重派发的语言来说，编程解决问题的实质就是去对问题进行拆分，拆分为一个个的类型（其中包含各种各样的数据），然后针对各个类型编写相应的函数。这和主流面向对象语言（如 C++, Python, Java）有点像，但也有不同，在研究范式的时候注意不要与面向对象的写法相混淆。","category":"page"},{"location":"paradigm_types_and_functions/#类型-1","page":"类型与函数范式","title":"类型","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"在科学计算中，类型本质上是一个数学对象，这个数学对象对应着某个物理概念，它能与其他的数学对象进行一定的运算。在这个前提下，我们就能理解为什么类型除了构造函数外并不像主流面向对象语言一样含有其他的方法（例如说，实数和实数向量有数乘运算，这个运算不应该属于实数，也不属于实数向量）；我们也能理解相比于类型的成员，我们更关心类型的方法（运算），因而 Julia 不能继承数据结构。一般来讲，我们在平时的学术讨论中高频提到什么概念，我们就应该把什么概念提取出来作为一个类型。例如，一个典型的分子动力学程序可以将系统、传播子和相（原子坐标）写成三个类型 System, Propagator, Phase。","category":"page"},{"location":"paradigm_types_and_functions/#类型的成员处于同一抽象层级-1","page":"类型与函数范式","title":"类型的成员处于同一抽象层级","text":"","category":"section"},{"location":"paradigm_types_and_functions/#不要把类型成员的类型标注限制得太死-1","page":"类型与函数范式","title":"不要把类型成员的类型标注限制得太死","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"例如，我们可能会想把一个粒子的质量设为 64 位浮点数","category":"page"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"struct Particle\n    m::Float64\n    ...\nend","category":"page"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"但这实际上是没必要的。质量只要是个实数，不管实际在计算机上的实现是整数、有理数、16 位 32 位浮点数，都能完成我们需要的运算，所以不如直接设为 Real 抽象类型。在使用某些第三方库时（如自动微分），这种设置可能是必需的。","category":"page"},{"location":"paradigm_types_and_functions/#函数-1","page":"类型与函数范式","title":"函数","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"函数本质上是数学对象之间的运算，所以函数并不属于某个对象。有些时候一个物理概念既适合作为一个类型也适合作为一个函数（例如算符），这时可以先写类型，然后重载类型的调用（类似于 Python 中的 __call__ 方法）；当然一元函数很多时候跟乘法没有什么太大的区别（比如说 H(ψ) = Hψ），所以也可以写一个乘法来处理这种情况。我比较倾向于第一种。","category":"page"},{"location":"paradigm_types_and_functions/#一个函数可以干好几件事，但一个方法只能干一件事-1","page":"类型与函数范式","title":"一个函数可以干好几件事，但一个方法只能干一件事","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"函数应该短小（不超过 20 行，最好不超过 10 行），","category":"page"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"不要在函数内部判断变量的类型，而是拆分成不同的方法；\n不要传入一个 true 或者 false 以在函数内部改变函数的行为，而是拆分成不同的方法；\n","category":"page"},{"location":"paradigm_types_and_functions/#函数的计算处于同一抽象层级-1","page":"类型与函数范式","title":"函数的计算处于同一抽象层级","text":"","category":"section"},{"location":"paradigm_types_and_functions/#克制的参数个数-1","page":"类型与函数范式","title":"克制的参数个数","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"最好的函数有一个参数（对应于数学上的某种映射），次好的函数有两个参数（对应于数学上的某种运算），如果发现需要三个或者以上的参数就说明代码写得不好。有两种解决方法：","category":"page"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"把参数变为关键字参数，这适合构造函数等需要传入大量参数的情况；\n把几个有关联的参数封装为类型。","category":"page"},{"location":"paradigm_types_and_functions/#只有很有限的几个函数能访问某个类型的成员-1","page":"类型与函数范式","title":"只有很有限的几个函数能访问某个类型的成员","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"我们更关心类型的行为而不是成员，因此如果一个类型的某个成员在许多函数中都被访问了，说明需要定义新的函数承接对这个成员的访问。","category":"page"},{"location":"paradigm_types_and_functions/#只跟熟人打交道-1","page":"类型与函数范式","title":"只跟熟人打交道","text":"","category":"section"},{"location":"paradigm_types_and_functions/#","page":"类型与函数范式","title":"类型与函数范式","text":"函数不应该调用那些自己定义的用来处理参数以外的值的函数。","category":"page"},{"location":"misc/#其他-1","page":"其他","title":"其他","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"","category":"page"},{"location":"misc/#流输入输出-1","page":"其他","title":"流输入输出","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"所有的流都具备读写方法，例如：","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"write(stdout, \"Hello world\");\nread(stdin, Char)","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"我们可以通过 readline() 函数一次读取整行；","category":"page"},{"location":"misc/#文件输入输出-1","page":"其他","title":"文件输入输出","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"可以通过 open 函数创建一个流，进行读写：","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"f = open(\"hello.txt\")\nreadlines(f)\nf = open(\"hello.txt\", \"w\")\nwrite(f, \"hello again.\")","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"为了避免使用太多的 close 函数，我们可以简单地使用 do 语法：","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"open(\"hello.txt\") do f\n    uppercase(read(f, String))\nend","category":"page"},{"location":"misc/#模块-1","page":"其他","title":"模块","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"模块的本质是一个全局作用域，可以创建全局变量。","category":"page"},{"location":"misc/#using-语句-1","page":"其他","title":"using 语句","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"using 语句意味着该模块的作用域会用于解析当前变量，也即导入它所有导出的变量。","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"using MyModule：导入所有的导出变量，以 MyModule. 为前缀导入所有的变量，并使所有函数以 MyModule. 为前缀可扩展；\nusing MyModule: x, p：导入给定的变量；","category":"page"},{"location":"misc/#import-语句-1","page":"其他","title":"import 语句","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"import MyModule：以 MyModule. 为前缀导入所有的变量，以 MyModule. 为前缀使所有函数可扩展；\nimport MyModule: x, p：导入给定的变量，并使给定变量可扩展。","category":"page"},{"location":"misc/#模块与文件的关系-1","page":"其他","title":"模块与文件的关系","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"模块与文件解耦，可以在任何模块中导入任何文件。","category":"page"},{"location":"misc/#相对路径导入-1","page":"其他","title":"相对路径导入","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"例如，在模块中引用子模块时，需要使用：","category":"page"},{"location":"misc/#","page":"其他","title":"其他","text":"module Parent\nusing .Utils\nend","category":"page"},{"location":"misc/#文件包含-1","page":"其他","title":"文件包含","text":"","category":"section"},{"location":"misc/#","page":"其他","title":"其他","text":"文件包含的本质是将给定的源代码文件放到当前作用域上求值。","category":"page"},{"location":"paradigm_documentation/#文档范式-1","page":"文档范式","title":"文档范式","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"这里「文档」是广义的，它包括我们在工作的时候写的一切除了代码之外的东西：注释、（真正的）文档、报告和论文。","category":"page"},{"location":"paradigm_documentation/#注释-1","page":"文档范式","title":"注释","text":"","category":"section"},{"location":"paradigm_documentation/#没有注释好过有注释-1","page":"文档范式","title":"没有注释好过有注释","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"通过合理地运用命名，合理地将任务拆分为一个个类型和函数，我们本来可以避免使用注释。每当需要写注释的时候，考虑一下能否通过代码表达。","category":"page"},{"location":"paradigm_documentation/#如果需要注释，注释意图而不是内容-1","page":"文档范式","title":"如果需要注释，注释意图而不是内容","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"当我们实在需要注释的时候，将代码的内容用文字再表述一遍并不能增加代码的可读性。这里有几种可能的情况：","category":"page"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"一是我们将一些复杂运算的其中一些步骤用纸笔进行计算，然后把中间结果写进了代码。例如以下程序构造了一个循环矩阵的本征矢量构成的矩阵：","category":"page"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"# T 是广义本征值问题 M x = λ K x 的本征矢量构成的矩阵\nT = zeros(n,n)\nT[:,1] .= sqrt(1 / n)\nfor i in 1:(n-1)÷2\n    c1, c2 = i+1, n+1-i\n    T[:,c1] .= sqrt(2 / n) .* [cos(2π * i * (j-1) / n) for j in 1:n]\n    T[:,c2] .= sqrt(2 / n) .* [sin(2π * i * (j-1) / n) for j in 1:n]\nend\nif n % 2 == 0\n    T[:,n÷2+1] .= sqrt(1 / n) .* [(-1)^(i-1) for i in 1:n]\nend","category":"page"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"通过添加注释我们能说明这些复杂运算的意义。更好的做法则是使用文档，在文档中给出详细的数学推导说明这样做的合理性，参见下一节。","category":"page"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"二是我们在写代码的时候做出了一些考虑和决定，我们需要对这些决定进行说明以使（以后的）自己和他人明白。","category":"page"},{"location":"paradigm_documentation/#文档-1","page":"文档范式","title":"文档","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"文档分为描述文档和 API 文档。","category":"page"},{"location":"paradigm_documentation/#先有（描述）文档，再有代码-1","page":"文档范式","title":"先有（描述）文档，再有代码","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"首先在文档中推导公式，检验公式正确无误后，再把公式翻译成代码，并且与公式逐行校对，在代码中应该加入一个链接指向文档中的公式。","category":"page"},{"location":"paradigm_documentation/#通过代码中的类型说明和函数说明生成（API）文档（Documenter.jl）-1","page":"文档范式","title":"通过代码中的类型说明和函数说明生成（API）文档（Documenter.jl）","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"如果代码需要发布给别人看，可以通过对每个类型和函数写 docstring 的方式添加文档，这种写法有比较规范的标准，就不赘述了。具体使用方法可以参考 https://juliadocs.github.io/Documenter.jl/stable/。","category":"page"},{"location":"paradigm_documentation/#报告和论文-1","page":"文档范式","title":"报告和论文","text":"","category":"section"},{"location":"paradigm_documentation/#","page":"文档范式","title":"文档范式","text":"计算结果得到的数据和图片等等可以直接加入描述文档中。如果描述文档写得好，可以通过 Pandoc 转换为 PDF 直接作为组会报告的材料，再加工加工可以直接变成论文，全程跟代码一起用 Git 做版本管理，可以说是一气呵成了。","category":"page"},{"location":"paradigm_tests/#测试范式-1","page":"测试范式","title":"测试范式","text":"","category":"section"},{"location":"paradigm_tests/#测试代码也是代码-1","page":"测试范式","title":"测试代码也是代码","text":"","category":"section"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"覆盖率高的测试使我们的程序可维护，因为每次进行改动只需要确保通过测试就可以了。因此，测试决不是用完就扔的代码，而应该自动化地运行，以使得每一次改动都没有后顾之忧。","category":"page"},{"location":"paradigm_tests/#先有测试函数，再有运算函数-1","page":"测试范式","title":"先有测试函数，再有运算函数","text":"","category":"section"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"程序应该依类型和类型上的函数而内聚成一个个的文件，一个文件可以近似地看成是一个单元。在编写一个文件的时候，我们应该先写类型和运算函数的签名，然后在文件底部写好测试函数，使得这个测试恰好无法通过；然后我们去编写实际执行运算的函数，使得测试由不通过转为可以通过。","category":"page"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"在小型项目中，可以在每个文件中加入","category":"page"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"if basename(PROGRAM_FILE) == basename(@__FILE__)\n    test()\nend","category":"page"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"来运行测试，而在大型项目中最好单独运用测试。","category":"page"},{"location":"paradigm_tests/#测试的内部结构-1","page":"测试范式","title":"测试的内部结构","text":"","category":"section"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"好的测试应该总是能拆分为「构造测试用例」——「运算」——「断言」三部分，其中断言可以用 @assert 宏实现。例如如果我们构造的一个类型中含有一个正交矩阵，断言正交矩阵乘以它的转置是不是约等于单位矩阵应该是一个好的断言。","category":"page"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"operator = Operator(...)\n@assert operator.T * operator.T' ≈ operator.T' * operator.T ≈ I","category":"page"},{"location":"paradigm_tests/#如何获得测试用例-1","page":"测试范式","title":"如何获得测试用例","text":"","category":"section"},{"location":"paradigm_tests/#","page":"测试范式","title":"测试范式","text":"测试程序的基础功能是不是能跑通；\n文献上的计算结果；\n组内公认的计算结果；\n自己积累的一些小模型系统的计算结果。","category":"page"},{"location":"metaprogramming/#元编程-1","page":"元编程","title":"元编程","text":"","category":"section"},{"location":"metaprogramming/#表达式对象的结构-1","page":"元编程","title":"表达式对象的结构","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"expr.head：一个符号，表明了表达式的类型\nexpr.args：一个列表，表明了表达式的参数，可以是符号、其他表达式或字面值","category":"page"},{"location":"metaprogramming/#创建表达式对象-1","page":"元编程","title":"创建表达式对象","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"将 Julia 语言的一个合法表达式用适当的方式引用起来，就形成了一个表达式对象：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"expr = :(1 + 1)\nexpr = Expr(:call, :+, 1, 1)\nexpr = Meta.parse(\"1 + 1\")","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"当我们需要多行的表达式时，也可以使用 quote 语法：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"expr = quote\n    x = 1\n    y = 2\n    x + y\nend","category":"page"},{"location":"metaprogramming/#创建表达式对象的同时进行插值-1","page":"元编程","title":"创建表达式对象的同时进行插值","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"我们可以将字面值或表达式作为新表达式的一部分插入，并用 $ 号标记：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"a = 1\nexpr = :($a + b)","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"我们也可以先将一个变量展开，然后再插值：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"args = [:x, :y, :z]\n:(f(1, $(args...)))","category":"page"},{"location":"metaprogramming/#符号对象-1","page":"元编程","title":"符号对象","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"用 : 可以创建一个符号：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":":foo\nSymbol(\"foo\")","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"当表达式被求值的时候，一个符号会被一个变量替代。","category":"page"},{"location":"metaprogramming/#表达式求值-1","page":"元编程","title":"表达式求值","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"我们可以在全局作用域来对表达式进行求值：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"eval(:(1 + 1)) # =2","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"每个模块都有自己的求值函数。表达式不仅能返回一个值，还能影响模块的环境：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"expr = :(x = 1)\neval(expr)\nx # 1","category":"page"},{"location":"metaprogramming/#以表达式为值的函数-1","page":"元编程","title":"以表达式为值的函数","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"在函数中，我们可以使 Expr 函数构建表达式，并将其返回。","category":"page"},{"location":"metaprogramming/#宏-1","page":"元编程","title":"宏","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"宏接受一系列参数（可以是符号、字面值和表达式），然后将它们转化为一个表达式，这个表达式能够直接参与编译。","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"macro sayhello(name)\n    return :( println(\"Hello, \", $name) )\nend","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"我们可以用 macroexpand 函数来测试宏：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"expr = macroexpand(Main, :(@sayhello(\"human\")))\nexpr = @macroexpand @sayhello \"human\"","category":"page"},{"location":"metaprogramming/#宏的使用-1","page":"元编程","title":"宏的使用","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"宏可以用三种不同的语法使用：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"@name expr1 expr2 ...\n@name(expr1, expr2, ...)\n@name[a b]","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"除了给定的参数外，宏还有两个额外的参数：__source__ 和 __module__，第一个可以用于查看调用的位置，而第二个反映了调用的上下文。","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"宏也是泛型的，可以接受很多个参数，但参数的类型是 AST 中的类型，而不是变量所代表的对象。","category":"page"},{"location":"metaprogramming/#元编程的应用-1","page":"元编程","title":"元编程的应用","text":"","category":"section"},{"location":"metaprogramming/#自定义类-1","page":"元编程","title":"自定义类","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"考虑一个仅包含浮点数的自定义类，我们可以通过如下方式快速操作：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"for op = (:sin,:cos,:tan,:log,:exp)\n    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))\nend","category":"page"},{"location":"metaprogramming/#自定义字符串字面值-1","page":"元编程","title":"自定义字符串字面值","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"正则表达式实际上是一个具有特殊语法的宏：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"macro r_str(p)\n    Regex(p)\nend","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"这样，我们就能使用 r\"string\" 这样的表达了。","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"另外，我们也可以定义特殊的命令字面值，通过 c`literal` 我们实际上获得的是 @c_cmd \"literal\"。","category":"page"},{"location":"metaprogramming/#生成函数-1","page":"元编程","title":"生成函数","text":"","category":"section"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"生成函数能让我们生成专门化的代码，取决于参数的种类，而不需要每种都用多重派发来实现。这样的函数返回一个引用的表达式作为方法的函数体，然后进行编译。具体的做法是：","category":"page"},{"location":"metaprogramming/#","page":"元编程","title":"元编程","text":"用 @generated 标记该宏；\n在函数体中，我们通过变量的类型生成应该实现的代码并返回；\n生成函数只能调用那些已经定义好的函数；\n生成函数不能改变全局状态。","category":"page"},{"location":"functional_programming/#函数式编程-1","page":"函数式编程","title":"函数式编程","text":"","category":"section"},{"location":"functional_programming/#写好函数，而不是写好脚本-1","page":"函数式编程","title":"写好函数，而不是写好脚本","text":"","category":"section"},{"location":"functional_programming/#","page":"函数式编程","title":"函数式编程","text":"函数式编程意味着将程序运行的结果表达为输入数据的函数。在实际运用中，它表现出了以下特点：","category":"page"},{"location":"functional_programming/#","page":"函数式编程","title":"函数式编程","text":"函数的返回值完全由参数确定；\n函数不改变参数；\n除非出于输入/输出和内存管理的需要，尽量使得对象不改变。","category":"page"},{"location":"functional_programming/#-1","page":"函数式编程","title":"","text":"","category":"section"},{"location":"topics/#Julia-专题-1","page":"Julia 专题","title":"Julia 专题","text":"","category":"section"},{"location":"topics/#并行计算-1","page":"Julia 专题","title":"并行计算","text":"","category":"section"},{"location":"topics/#包管理-1","page":"Julia 专题","title":"包管理","text":"","category":"section"},{"location":"topics/#原理-1","page":"Julia 专题","title":"原理","text":"","category":"section"},{"location":"topics/#","page":"Julia 专题","title":"Julia 专题","text":"安装一个包的过程：","category":"page"},{"location":"topics/#","page":"Julia 专题","title":"Julia 专题","text":"查询注册表；\n下载包的源代码；\n下载二进制依赖。","category":"page"},{"location":"topics/#","page":"Julia 专题","title":"Julia 专题","text":"在默认情况下，使用官方服务器，会根据地域自动导流到下述的区域服务器上：","category":"page"},{"location":"topics/#","page":"Julia 专题","title":"Julia 专题","text":"北京 https://cn-northeast.pkg.juliacn.com\n上海 https://cn-east.pkg.juliacn.com\n广州 https://cn-southeast.pkg.juliacn.com\n韩国 https://kr.pkg.julialang.org\n新加坡 https://sg.pkg.julialang.org\n北美 https://us-east.pkg.julialang.org","category":"page"},{"location":"topics/#","page":"Julia 专题","title":"Julia 专题","text":"然后上述三种内容都从官方服务器获取。","category":"page"},{"location":"topics/#使用镜像-1","page":"Julia 专题","title":"使用镜像","text":"","category":"section"},{"location":"topics/#","page":"Julia 专题","title":"Julia 专题","text":"在集群上，由于未知原因无法使用华东服务器，所以转而使用北京外国语大学镜像站，使用手册见这里。镜像站只包含注册表和 Julia 源码，不包含二进制依赖。","category":"page"},{"location":"topics/#自动微分-1","page":"Julia 专题","title":"自动微分","text":"","category":"section"},{"location":"package/#创建包-1","page":"创建包","title":"创建包","text":"","category":"section"},{"location":"package/#","page":"创建包","title":"创建包","text":"首先在默认环境下（如 @v1.5）安装 PkgTemplates.jl。","category":"page"},{"location":"package/#","page":"创建包","title":"创建包","text":"然后，执行以下脚本：","category":"page"},{"location":"package/#","page":"创建包","title":"创建包","text":"using PkgTemplates\n  \nt = Template(\n    user=\"tansongchen\",\n    authors=\"Songchen Tan\",\n    julia=v\"1.5\",\n    plugins=[\n        Codecov(),\n        Documenter{GitHubActions}(),\n        Git(name=\"tansongchen\", email=\"tansongchen@pku.edu.cn\", ssh=true),\n        GitHubActions()\n    ]\n)\n\nt(\"PACKAGE_NAME\")","category":"page"},{"location":"package/#","page":"创建包","title":"创建包","text":"同时在 GitHub 上创建相应的仓库，但不需要马上导入。","category":"page"},{"location":"package/#修复-1","page":"创建包","title":"修复","text":"","category":"section"},{"location":"package/#","page":"创建包","title":"创建包","text":"删除 DOCUMENTER_KEY；\n修复 README.md 中的自定义域名；\n修复 make.jl 中的自定义域名；\n修复 remote origin","category":"page"},{"location":"package/#配置-Codecov-1","page":"创建包","title":"配置 Codecov","text":"","category":"section"},{"location":"package/#","page":"创建包","title":"创建包","text":"在 Codecov 网站上选择该仓库，复制 token；在仓库的 Secrets 中加入 CODECOV_TOKEN。","category":"page"},{"location":"package/#加入示例语句-1","page":"创建包","title":"加入示例语句","text":"","category":"section"},{"location":"package/#","page":"创建包","title":"创建包","text":"在 Package.jl 中加入：","category":"page"},{"location":"package/#","page":"创建包","title":"创建包","text":"export double\n\nconst double = x -> 2x","category":"page"},{"location":"package/#","page":"创建包","title":"创建包","text":"在 runtests 中加入：","category":"page"},{"location":"package/#","page":"创建包","title":"创建包","text":"@test double(1) == 2","category":"page"},{"location":"package/#第一次推送至仓库-1","page":"创建包","title":"第一次推送至仓库","text":"","category":"section"},{"location":"package/#","page":"创建包","title":"创建包","text":"设置好 Page 的问题","category":"page"},{"location":"functions_and_methods/#函数与方法-1","page":"函数与方法","title":"函数与方法","text":"","category":"section"},{"location":"functions_and_methods/#函数声明-1","page":"函数与方法","title":"函数声明","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"function f(x, y)\nend","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"也可以用赋值式声明：f(x, y) = x + y。","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"函数的返回值可以显式声明，也可以用 return 声明。可以使用 return nothing。","category":"page"},{"location":"functions_and_methods/#匿名函数-1","page":"函数与方法","title":"匿名函数","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"函数是一等公民，所以可以用如下的方法赋值：","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"x -> x^2 + 2x - 1","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"这些函数通常传给泛函。","category":"page"},{"location":"functions_and_methods/#元组与多返回值函数-1","page":"函数与方法","title":"元组与多返回值函数","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"元组是多个对象的序列，不可变；可以创建元组。函数返回多值时，是作为元组返回，同时可以进行解构赋值。","category":"page"},{"location":"functions_and_methods/#阵列字面值-1","page":"函数与方法","title":"阵列字面值","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"我们可以通过中括号来创建阵列字面值：[A, B, C, ...]，其中元素类型由它们自动决定：","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"如果元素都属于同一类型，就是这个类型；\n如果元素有共同的提升类型，则为提升类型；\n类型为 Any。","category":"page"},{"location":"functions_and_methods/#阵列字面值的纵向连接-1","page":"函数与方法","title":"阵列字面值的纵向连接","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"如果方括号内的元素由分号或者新行连接，那么它们会被认为是元素的集合，而非自身；如果由制表符或空格连接，则会被认为是创建了新的列。实例：","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"[1:2; 4:5] # 4 × 1\n[1:2 4:5] # 2 × 2\n[1 2 3] # 1 × 3\n[1 2; 3 4] # 2 × 2","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"这些只不过是一个函数的别名：","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"cat：在任意维度上组合；\nvcat：在一维上组合；\nhcat：在二维上组合；","category":"page"},{"location":"functions_and_methods/#阵列推导-1","page":"函数与方法","title":"阵列推导","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"通用的语法：","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"A = [ F(x, y, ...) for x = rx, y = ry, ...]","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"这里 rx, ry 都是可迭代对象。","category":"page"},{"location":"functions_and_methods/#生成器-1","page":"函数与方法","title":"生成器","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"若列表不包含括号，则视为一个生成器，通过迭代来得到值，而不需要任何阵列。","category":"page"},{"location":"functions_and_methods/#指标-1","page":"函数与方法","title":"指标","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"函数形式：getindex(A, ...)","category":"page"},{"location":"functions_and_methods/#标量指标-1","page":"函数与方法","title":"标量指标","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"如果所有的指标都是标量，那么结果是一个元素；","category":"page"},{"location":"functions_and_methods/#向量指标-1","page":"函数与方法","title":"向量指标","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"如果所有的指标都是向量，那么结果是一个 N 维阵列，阵列的大小是 length(I_1), ...., length(I_n)。","category":"page"},{"location":"functions_and_methods/#二维阵列指标-1","page":"函数与方法","title":"二维阵列指标","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"结果是一个 N+1 维阵列，大小是 size(I_1, 1), size(I_1, 2), ...","category":"page"},{"location":"functions_and_methods/#指标赋值-1","page":"函数与方法","title":"指标赋值","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"函数形式：setindex!(A, X, ...)","category":"page"},{"location":"functions_and_methods/#子阵列-1","page":"函数与方法","title":"子阵列","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"子阵列与母阵列共享同样的内存，可以通过 view 创建，它的参数与 getindex() 相同。","category":"page"},{"location":"functions_and_methods/#广播-1","page":"函数与方法","title":"广播","text":"","category":"section"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"当我们需要在不同大小的阵列间进行二元运算时，我们可以用广播函数将大小为一的维度扩增然后进行运算：","category":"page"},{"location":"functions_and_methods/#","page":"函数与方法","title":"函数与方法","text":"a = rand(2, 1);\nA = rand(2, 3);\nbroadcast(+, a, A);","category":"page"},{"location":"#科学计算中的程序设计概论-1","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"","category":"section"},{"location":"#一、代码猴子-1","page":"科学计算中的程序设计概论","title":"一、代码猴子","text":"","category":"section"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"你是一位程序设计师，还是一个代码猴子？","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"「代码猴子」（Code Monkey）一词出自《代码整洁之道》一书，意指那些在程序设计时随心所欲、上蹿下跳的程序员，他们不经意间的、也许是善意的行动反而使得代码结构混乱，无法维护。程序设计师和代码猴子的区别就在于程序设计范式。在程序设计中，范式一词表示了程序设计背后的思想和程序通常遵循的结构风格。以下一段定义引自中文维基百科：","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"程序设计范式是一类典型的编程风格，是指从事软件工程的一类典型的风格（可以对照方法学）。如：函数式编程、过程式编程、面向对象编程、指令式编程等等为不同的编程范型。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"显然，良好的程序设计范式使得程序易于维护、易于根据需求的不断变化而不断更新迭代，减少出错概率，增强团队协作的效率。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"程序设计的典型应用场景是软件工程，其业内已经形成了一套稳定的编程范式，可以作为领域内学习者参照的范本。然而，作为另一个重要的应用场景——科学计算，则由于从业者基本不是计算机相关专业出身等原因，并没有形成稳定的编程范式；同时又由于其特点而不能直接应用软件工程中的编程范式（如面向对象等）。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"科学计算是理论与计算化学研究的重要组成部分之一。在课题组参与研究的过程中，我发现组内的高年级本科生和研究生经常花很多时间调试程序，但仍然经常出错，这在一定程度上是程度设计范式的缺失和思维的混乱所导致的必然结果。因此，非常有必要对适合于科学计算的程序设计范式进行研究，总结出一套自己的方法论，服务于未来的需求。","category":"page"},{"location":"#二、关于函数式编程-1","page":"科学计算中的程序设计概论","title":"二、关于函数式编程","text":"","category":"section"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"谈到程序设计范式，我们首先需要对它进行细致的分类。在最高的层级上，程序设计范式可以分为两大类：指令式（imperative）编程和描述式（declarative）编程。抽象地看，对于同样的一段计算过程，指令式编程认为这一过程的本质是对一系列数据进行修改，而描述式编程则认为这一过程的本质是一系列的声明，每一步声明都包括了计算结果与各种数据的关系。为了使得这两种范式的本质区别得到更好的理解，我们假设我们现在要做一道菜「蛋炒饭」，则指令式程序可能看起来像是：","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"大火将油烧热，将鸡蛋搅匀后倒入锅中，炒至金黄后盛入碗中；向锅中加入葱花和剩米饭，炒散后加入炒好的鸡蛋，再加入胡萝卜丁和火腿丁翻炒几分钟即可。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"而描述式程序可能看起来像是：","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"「炒好的鸡蛋」是蛋液在与油混合炒至金黄得到的产物；「炒好的米饭和葱花」是米饭和葱花混合炒散得到的产物；「蛋炒饭」是「炒好的鸡蛋」与「炒好的米饭和葱花」混合并加入胡萝卜丁和火腿丁翻炒几分钟得到的产物。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"不得不承认，指令式程序更接近人的思维习惯和做事习惯，描述式程序则看起来罗嗦、怪怪的。历史上，从 C 和 Lisp 语言的时代开始，这两门语言分别代表了指令式和描述式编程，在二十余年的大战中以指令式编程全面胜出而告终。指令式编程内部又可以划分为面向过程编程（修改的主体是子程序）和面向对象编程（修改的主体是一个抽象实体），其中面向对象编程已经成为了软件开发领域的共识。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"那么，本专栏为什么又要强调描述式编程呢？一个简单的回答是科学计算并不是软件开发，科学计算的目的决定了描述式编程更为适合。描述式编程内部又可以再分为函数式编程、逻辑式编程和优化式编程，我们这里只讨论函数式编程。函数式编程，顾名思义，是将程序计算的结果描述为一系列函数（映射）的结果。例如输入数据是 x，则一个函数式程序可能是（x, y, z, w 可以是任意数据）：","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"input x\ny = f(x)\nz = g(x,y)\nw = h(y,z)\noutput w","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"这里「函数」倾向于是数学意义上的函数，即给定一组参数，能够唯一确定地返回一个结果，不存在内部的状态，也不修改参数本身。这样的话，在实际操作中，函数式编程有以下几个优点：","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"由于不存在内部的状态也不修改参数，函数没有任何的副作用，在任何情况下行为都是一样的，有利于调试；\n函数和函数之间只需要通过数据进行交互，不需要考虑环境的影响；\n在并行计算中，多个处理器上的并行可以理解为多个处理器对不同的数据执行同一函数，减少了并行程序的编写难度。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"此外，从人的认知层面讲，在学习科学理论时物理量和物理量之间的关系一般都是用数学意义上的函数来表达的，函数式编程有利于将程序和科学认识进行对接，从而减轻认知负担，使得我们可以更加专注于科学本身。函数式编程的更多内容将在下一篇文章中有所提及。","category":"page"},{"location":"#三、关于-Julia-1","page":"科学计算中的程序设计概论","title":"三、关于 Julia","text":"","category":"section"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"Julia 是一门函数式的面向科学计算领域的语言，它的优点我就太长不讲了，有兴趣可以参考这个知乎回答。在这里我只记录一下学习和配置的方法。","category":"page"},{"location":"#macOS-1","page":"科学计算中的程序设计概论","title":"macOS","text":"","category":"section"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"从官网下载二进制文件；\n移动到 /Applications/Julia.app\n运行 Shell 命令 ln -s /Applications/Julia.app/Contents/Resources/julia/bin/julia /usr/local/bin/julia\n在 Visual Studio Code 中下载 Julia 插件并填写路径。","category":"page"},{"location":"#Linux-1","page":"科学计算中的程序设计概论","title":"Linux","text":"","category":"section"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"从官网下载二进制文件；\n解压到 ~/local/julia\n类似地配置环境变量。","category":"page"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"直接看官网提供的手册就可以学习。另外知乎罗秀哲的回答值得参考。","category":"page"},{"location":"#四、关于本专栏-1","page":"科学计算中的程序设计概论","title":"四、关于本专栏","text":"","category":"section"},{"location":"#","page":"科学计算中的程序设计概论","title":"科学计算中的程序设计概论","text":"本专栏分为两部分：第一部分是关于程序设计范式的整体介绍，第二部分是 Julia 语言的学习（没写完）。","category":"page"},{"location":"types/#类型系统-1","page":"类型系统","title":"类型系统","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Julia 中的类型分为抽象类型和具象类型，其中抽象类型是不可实例化的，而具象类型是可以实例化。类型之间构成了类型树，所有的具象类型都是树的叶节点，而所有的抽象类型都是树的非叶节点。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"类型的类型是 DataType。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"类型树：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Any\nNumber\nReal\nInteger\nSigned\nUnsigned\nAbstractFloat\nAbstractString","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"抽象类型的声明：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"abstract type $typeName end\nabstract type $typeName <: $supertypeName end","category":"page"},{"location":"types/#具象类型-1","page":"类型系统","title":"具象类型","text":"","category":"section"},{"location":"types/#原始类型-1","page":"类型系统","title":"原始类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"原始类型：数据只包含特定数量的比特。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"primitive type $typeName $typeBits end\nprimitive type $typeName <: $supertypeName $typeBits end","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"实例：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"AbstractFloat 抽象类型衍生了 Float16, Float32, Float64\nInteger 抽象类型衍生了 Bool\nSigned 抽象类型衍生了 Int8 ~ Int128\nUnsigned 抽象类型衍生了 UInt8 ~ UInt128\nAbstractChar 抽象类型衍生了 Char","category":"page"},{"location":"types/#复合类型-1","page":"类型系统","title":"复合类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"复合类型包含了一系列命名的域，每个域都是一个原始类型或复合类型。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"声明方式：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"struct Foo\n    bar\n    baz::Int\n    qux::Float64\nend","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"查看域：fieldnames(Foo)","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"访问域：foo.bar","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"复合类型是不可变的；如果可变，则要声明为 mutable struct。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"不可变的、不含任何域的复合类型是单例类型。","category":"page"},{"location":"types/#构造函数-1","page":"类型系统","title":"构造函数","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"自带两个构造函数：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"接受任何参数，并转换为类型\n只接受对应的参数","category":"page"},{"location":"types/#类型并集-1","page":"类型系统","title":"类型并集","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"类型并集是一个抽象类型，它包括了所有的成员所能包括的对象。","category":"page"},{"location":"types/#参数化类型-1","page":"类型系统","title":"参数化类型","text":"","category":"section"},{"location":"types/#以类型为参数的复合类型-1","page":"类型系统","title":"以类型为参数的复合类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"struct Point{T}\n    x::T\n    y::T\nend","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"这定义了无穷多可能的类型，例如 Point{Float64} 是一个具象类型。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"参数复合类型本身也是一个类型，并且是所有参数化后的类型的基类：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Point{Float64} <: Point","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"函数定义","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"function norm(p::Point{<:Real})\n    sqrt(p.x^2 + p.y^2)\nend","category":"page"},{"location":"types/#参数类型的构造函数-1","page":"类型系统","title":"参数类型的构造函数","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"类型参数显明的给出\n通过参数动态确定","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"例如，","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Point{Float64}(1.0, 2.0)","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"也可以用未参数化的形式","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Point(1.0, 2.0)","category":"page"},{"location":"types/#参数抽象类型-1","page":"类型系统","title":"参数抽象类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"abstract type Pointy{T} end","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"给定任意 T 的值，都会生成一个类型。同时它们也满足","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Pointy{Float64} <: Pointy{<:Real}","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"我们可以定义一个参数复合类型作为它的具象化类型，也是子类型。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"abstract type Pointy{T<:Real} end","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"例如，","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"struct Rational{T<:Integer} <: Real ... end","category":"page"},{"location":"types/#元组类型-1","page":"类型系统","title":"元组类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"元组类型实际上是一个元组的类型，它对应着一个任意多参数的参数复合类型。与其他不同的是，元组类型的参数是协变的，也即","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"Tuple{Int,AbstractString} <: Tuple{Real,Any}","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"元组类型的最后一个参数可以是 Vararg 类型，这表明元组的最后可以包含任何种类的数据。另外 NTuple{N,T} 是 Tuple{Vararg{T,N}} 的别名。","category":"page"},{"location":"types/#命名元组类型-1","page":"类型系统","title":"命名元组类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"命名元组有两个参数：第一个参数是符号元组，第二个参数是元组类型。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"命名元组可以作为一个构造函数，构造时可以包括两个参数，也可以只包括符号元组的参数。","category":"page"},{"location":"types/#单实例类型-1","page":"类型系统","title":"单实例类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"对于所有类型来说，Type{T} 是一个抽象类型，它唯一的实例是该类型。另外 Type 本身也是一个基类。","category":"page"},{"location":"types/#参数原始类型-1","page":"类型系统","title":"参数原始类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"原始类型也可以参数声明，例如指针依赖于类型：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"primitive type Ptr{T} 64 end","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"在这里，类型参数只是一个标签，而不参与自身的定义。","category":"page"},{"location":"types/#UnionAll-类型-1","page":"类型系统","title":"UnionAll 类型","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"参数类型的类型实际上是 UnionAll。所有的类型应用 A{B,C} 都要求 A 的类型是 UnionAll，并且我们可以部分地实例化它。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"类型变量可以通过子类关系来限制。","category":"page"},{"location":"types/#类型操作-1","page":"类型系统","title":"类型操作","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"由于类型本身是对象，可以用操作来处理它们。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"isa(1, Int)\ntypeof(Rational)\nsupertype(Number)","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"所有的类型的类型都是 DataType，它是自身的类型。","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"所有的类型的基类都是 Any。","category":"page"},{"location":"types/#值类-1","page":"类型系统","title":"值类","text":"","category":"section"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"我们不能根据对象是什么来派发，但我们可以将纯比特数据（通过参数）封装成一个类型，因而使用。例如，我们定义两个函数：","category":"page"},{"location":"types/#","page":"类型系统","title":"类型系统","text":"firstlast(::Val{true}) = \"First\"\nfirstlast(::Val{false}) = \"Last","category":"page"}]
}
