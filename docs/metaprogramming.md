# 元编程

## 表达式对象的结构

- `expr.head`：一个符号，表明了表达式的类型
- `expr.args`：一个列表，表明了表达式的参数，可以是符号、其他表达式或字面值

## 创建表达式对象

将 Julia 语言的一个合法表达式用适当的方式引用起来，就形成了一个表达式对象：

```julia
expr = :(1 + 1)
expr = Expr(:call, :+, 1, 1)
expr = Meta.parse("1 + 1")
```

当我们需要多行的表达式时，也可以使用 `quote` 语法：

```julia
expr = quote
    x = 1
    y = 2
    x + y
end
```

## 创建表达式对象的同时进行插值

我们可以将字面值或表达式作为新表达式的一部分插入，并用 `$` 号标记：

```julia
a = 1
expr = :($a + b)
```

我们也可以先将一个变量展开，然后再插值：

```julia
args = [:x, :y, :z]
:(f(1, $(args...)))
```

# 符号对象

用 : 可以创建一个符号：

```
:foo
Symbol("foo")
```

当表达式被求值的时候，一个符号会被一个变量替代。

# 表达式求值

我们可以在全局作用域来对表达式进行求值：

```julia
eval(:(1 + 1)) # =2
```

每个模块都有自己的求值函数。表达式不仅能返回一个值，还能影响模块的环境：

```julia
expr = :(x = 1)
eval(expr)
x # 1
```

## 以表达式为值的函数

在函数中，我们可以使 `Expr` 函数构建表达式，并将其返回。

# 宏

宏接受一系列参数（可以是符号、字面值和表达式），然后将它们转化为一个表达式，这个表达式能够直接参与编译。

```julia
macro sayhello(name)
    return :( println("Hello, ", $name) )
end
```

我们可以用 `macroexpand` 函数来测试宏：

```julia
expr = macroexpand(Main, :(@sayhello("human")))
expr = @macroexpand @sayhello "human"
```

## 宏的使用

宏可以用三种不同的语法使用：

```julia
@name expr1 expr2 ...
@name(expr1, expr2, ...)
@name[a b]
```

除了给定的参数外，宏还有两个额外的参数：`__source__` 和 `__module__`，第一个可以用于查看调用的位置，而第二个反映了调用的上下文。

宏也是泛型的，可以接受很多个参数，但参数的类型是 AST 中的类型，而不是变量所代表的对象。

# 元编程的应用

## 自定义类

考虑一个仅包含浮点数的自定义类，我们可以通过如下方式快速操作：

```julia
for op = (:sin,:cos,:tan,:log,:exp)
    @eval Base.$op(a::MyNumber) = MyNumber($op(a.x))
end
```

## 自定义字符串字面值

正则表达式实际上是一个具有特殊语法的宏：

```julia
macro r_str(p)
    Regex(p)
end
```

这样，我们就能使用 `r"string"` 这样的表达了。

另外，我们也可以定义特殊的命令字面值，通过 c\`literal\` 我们实际上获得的是 `@c_cmd "literal"`。

## 生成函数

生成函数能让我们生成专门化的代码，取决于参数的种类，而不需要每种都用多重派发来实现。这样的函数返回一个引用的表达式作为方法的函数体，然后进行编译。具体的做法是：

1. 用 `@generated` 标记该宏；
2. 在函数体中，我们通过变量的类型生成应该实现的代码并返回；
3. 生成函数只能调用那些已经定义好的函数；
4. 生成函数不能改变全局状态。

